{"ast":null,"code":"import { CanvasTexture } from 'three/src/textures/CanvasTexture';\nexport default class GifTexture extends CanvasTexture {\n  constructor(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n    super(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    this.needsUpdate = false;\n  }\n\n  setReader(reader) {\n    this.reader = reader;\n    this.image = document.createElement('canvas');\n    this.image.width = reader.width;\n    this.image.height = reader.height;\n    this.context = this.image.getContext('2d');\n    this.frameNumber = 0;\n    this.previousFrameInfo = null;\n    this.draw();\n  }\n\n  draw() {\n    if (!this.reader) {\n      return;\n    }\n\n    const {\n      reader,\n      image,\n      context\n    } = this;\n    const {\n      width,\n      height\n    } = image;\n    const frameNum = ++this.frameNumber % reader.numFrames();\n    const frameInfo = reader.frameInfo(frameNum);\n\n    if (frameNum === 0) {\n      // always clear canvas to start\n      context.clearRect(0, 0, width, height);\n    } else if (this.previousFrameInfo && this.previousFrameInfo.disposal === 2) {\n      // disposal was \"restore to background\" which is essentially \"restore to transparent\"\n      context.clearRect(this.previousFrameInfo.x, this.previousFrameInfo.y, this.previousFrameInfo.width, this.previousFrameInfo.height);\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    reader.decodeAndBlitFrameRGBA(frameNum, imageData.data);\n    context.putImageData(imageData, 0, 0);\n    this.needsUpdate = true;\n    this.previousFrameInfo = frameInfo;\n    setTimeout(this.draw.bind(this), frameInfo.delay * 10);\n  }\n\n}\n;","map":{"version":3,"sources":["/Users/bcraig/Desktop/TATLC/node_modules/three-gif-loader/lib/gif-texture.js"],"names":["CanvasTexture","GifTexture","constructor","image","mapping","wrapS","wrapT","magFilter","minFilter","format","type","anisotropy","needsUpdate","setReader","reader","document","createElement","width","height","context","getContext","frameNumber","previousFrameInfo","draw","frameNum","numFrames","frameInfo","clearRect","disposal","x","y","imageData","getImageData","decodeAndBlitFrameRGBA","data","putImageData","setTimeout","bind","delay"],"mappings":"AAAA,SAASA,aAAT,QAA8B,kCAA9B;AAEA,eAAe,MAAMC,UAAN,SAAyBD,aAAzB,CAAuC;AACpDE,EAAAA,WAAW,CAACC,KAAD,EAAQC,OAAR,EAAiBC,KAAjB,EAAwBC,KAAxB,EAA+BC,SAA/B,EAA0CC,SAA1C,EAAqDC,MAArD,EAA6DC,IAA7D,EAAmEC,UAAnE,EAA+E;AACxF,UAAMR,KAAN,EAAaC,OAAb,EAAsBC,KAAtB,EAA6BC,KAA7B,EAAoCC,SAApC,EAA+CC,SAA/C,EAA0DC,MAA1D,EAAkEC,IAAlE,EAAwEC,UAAxE;AAEA,SAAKC,WAAL,GAAmB,KAAnB;AACD;;AAEDC,EAAAA,SAAS,CAACC,MAAD,EAAS;AAChB,SAAKA,MAAL,GAAcA,MAAd;AAEA,SAAKX,KAAL,GAAaY,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAb;AACA,SAAKb,KAAL,CAAWc,KAAX,GAAmBH,MAAM,CAACG,KAA1B;AACA,SAAKd,KAAL,CAAWe,MAAX,GAAoBJ,MAAM,CAACI,MAA3B;AACA,SAAKC,OAAL,GAAe,KAAKhB,KAAL,CAAWiB,UAAX,CAAsB,IAAtB,CAAf;AAEA,SAAKC,WAAL,GAAmB,CAAnB;AACA,SAAKC,iBAAL,GAAyB,IAAzB;AACA,SAAKC,IAAL;AACD;;AAEDA,EAAAA,IAAI,GAAG;AACL,QAAI,CAAC,KAAKT,MAAV,EAAkB;AAChB;AACD;;AAED,UAAM;AAAEA,MAAAA,MAAF;AAAUX,MAAAA,KAAV;AAAiBgB,MAAAA;AAAjB,QAA6B,IAAnC;AACA,UAAM;AAAEF,MAAAA,KAAF;AAASC,MAAAA;AAAT,QAAoBf,KAA1B;AAEA,UAAMqB,QAAQ,GAAG,EAAE,KAAKH,WAAP,GAAqBP,MAAM,CAACW,SAAP,EAAtC;AACA,UAAMC,SAAS,GAAGZ,MAAM,CAACY,SAAP,CAAiBF,QAAjB,CAAlB;;AAEA,QAAIA,QAAQ,KAAK,CAAjB,EAAoB;AAClB;AACAL,MAAAA,OAAO,CAACQ,SAAR,CAAkB,CAAlB,EAAqB,CAArB,EAAwBV,KAAxB,EAA+BC,MAA/B;AACD,KAHD,MAGO,IAAI,KAAKI,iBAAL,IAA0B,KAAKA,iBAAL,CAAuBM,QAAvB,KAAoC,CAAlE,EAAqE;AAC1E;AACAT,MAAAA,OAAO,CAACQ,SAAR,CAAkB,KAAKL,iBAAL,CAAuBO,CAAzC,EACkB,KAAKP,iBAAL,CAAuBQ,CADzC,EAEkB,KAAKR,iBAAL,CAAuBL,KAFzC,EAGkB,KAAKK,iBAAL,CAAuBJ,MAHzC;AAID;;AAED,UAAMa,SAAS,GAAGZ,OAAO,CAACa,YAAR,CAAqB,CAArB,EAAwB,CAAxB,EAA2Bf,KAA3B,EAAkCC,MAAlC,CAAlB;AACAJ,IAAAA,MAAM,CAACmB,sBAAP,CAA8BT,QAA9B,EAAwCO,SAAS,CAACG,IAAlD;AACAf,IAAAA,OAAO,CAACgB,YAAR,CAAqBJ,SAArB,EAAgC,CAAhC,EAAmC,CAAnC;AAEA,SAAKnB,WAAL,GAAmB,IAAnB;AAEA,SAAKU,iBAAL,GAAyBI,SAAzB;AACAU,IAAAA,UAAU,CAAC,KAAKb,IAAL,CAAUc,IAAV,CAAe,IAAf,CAAD,EAAuBX,SAAS,CAACY,KAAV,GAAkB,EAAzC,CAAV;AACD;;AAlDmD;AAmDrD","sourcesContent":["import { CanvasTexture } from 'three/src/textures/CanvasTexture';\n\nexport default class GifTexture extends CanvasTexture {\n  constructor(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n    super(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n\n    this.needsUpdate = false;\n  }\n\n  setReader(reader) {\n    this.reader = reader;\n\n    this.image = document.createElement('canvas');\n    this.image.width = reader.width;\n    this.image.height = reader.height;\n    this.context = this.image.getContext('2d');\n\n    this.frameNumber = 0;\n    this.previousFrameInfo = null;\n    this.draw();\n  }\n\n  draw() {\n    if (!this.reader) {\n      return;\n    }\n\n    const { reader, image, context } = this;\n    const { width, height } = image;\n\n    const frameNum = ++this.frameNumber % reader.numFrames();\n    const frameInfo = reader.frameInfo(frameNum);\n\n    if (frameNum === 0) {\n      // always clear canvas to start\n      context.clearRect(0, 0, width, height);\n    } else if (this.previousFrameInfo && this.previousFrameInfo.disposal === 2) {\n      // disposal was \"restore to background\" which is essentially \"restore to transparent\"\n      context.clearRect(this.previousFrameInfo.x,\n                        this.previousFrameInfo.y,\n                        this.previousFrameInfo.width,\n                        this.previousFrameInfo.height);\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    reader.decodeAndBlitFrameRGBA(frameNum, imageData.data);\n    context.putImageData(imageData, 0, 0);\n\n    this.needsUpdate = true;\n\n    this.previousFrameInfo = frameInfo;\n    setTimeout(this.draw.bind(this), frameInfo.delay * 10);\n  }\n};\n"]},"metadata":{},"sourceType":"module"}